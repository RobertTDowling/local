.\" Automatically generated by Pod::Man v1.37, Pod::Parser v1.32
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sh \" Subsection heading
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  | will give a
.\" real vertical bar.  \*(C+ will give a nicer C++.  Capital omega is used to
.\" do unbreakable dashes and therefore won't be available.  \*(C` and \*(C'
.\" expand to `' in nroff, nothing in troff, for use with C<>.
.tr \(*W-|\(bv\*(Tr
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.Sh), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.if \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.\"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.hy 0
.if n .na
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "CALC 1"
.TH CALC 1 "2006-04-29" "perl v5.8.8" "User Contributed Perl Documentation"
.SH "NAME"
calc \- a small command line RPN calculator with hex/decimal and Forth stack
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
\&\fBcalc\fR
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
The \fBcalc\fR utility is an simple, small, command line interactive \s-1RPN\s0
calculator that supports decimal, hex and hours:minutes arithmetic,
similar to \fIdc\fR\|(1).
.Sh "Primary Differences From \fIdc\fP\|(1)"
.IX Subsection "Primary Differences From dc"
.IP "\(bu" 4
The stack is automatically displayed as a prompt when \fBcalc\fR is
waiting for more input.  The stack is displayed from bottom to top, so
that the \fItopmost\fR item is printed last, but is conveniently closest
to the user's cursor as he enters the next line of input.  (And I
think this is logical, since it preserves vertically the order that
operands were pushed).  
.Sp
If the input is \f(CW\*(C`10 20.5 30\*(C'\fR the stack will display as:
.RS 4
.Sp
.Vb 3
\& 3:                  0xa  10:00                   10
\& 2:                 0x14  20:30                 20.5
\& 1:                 0x1e  30:00                   30
.Ve
.RE
.RS 4
.RE
.IP "\(bu" 4
The stack is displayed in multiple formats at once: hex,
hours:minutes, and decimal.  At the left is the \*(L"depth\*(R" of each entry
on the stack.  The topmost item is at depth \fI1\fR.  
.Sp
\&\fBNote:\fR This depth number is what is used with the \fBP\fR operator
for selecting the item to be \*(L"picked\*(R".
.IP "\(bu" 4
Stack manipulation commands are initials of Forth common stack
manipulation words: \f(CW\*(C`drop\*(C'\fR, \f(CW\*(C`swap\*(C'\fR, \f(CW\*(C`dup\*(C'\fR, \f(CW\*(C`over\*(C'\fR, \f(CW\*(C`pick\*(C'\fR.  Only
\&\f(CW\*(C`dup\*(C'\fR has the wrong initial (\fBu\fR), as \f(CW\*(C`drop\*(C'\fR is the most common
operation.
.IP "\(bu" 4
The new \f(CW\*(C`:\*(C'\fR operator is a handy operator for converting
hours:minutes to fractional hours, while the stack automatically
displays values in both hours:minutes and fractional hours.
.Sh "General Operation"
.IX Subsection "General Operation"
\&\fBCalc\fR starts by giving a short help line and then it enters an
infinite input loop, expecting a line of text from the standard input.
This line is evaluated and any results left remaining on the stack are
displayed.  The loop starts again, expecting and then processing another
line of input.
.PP
\fIParsing Operands\fR
.IX Subsection "Parsing Operands"
.PP
Operands (numbers) are delimited by white space or an operator, and
can be entered as decimal integers, floating point, hexadecimal
integers using C's \f(CW\*(C`0x\f(CInnn\f(CW\*(C'\fR notation, octal integers using C's
\&\f(CW\*(C`0\f(CInnn\f(CW\*(C'\fR, or binary integers using Perl's \f(CW\*(C`0b\f(CInnn\f(CW\*(C'\fR notation.
Because \fIperl\fR\|(1) is used to parse the numbers, it accepts all of
perl's enhancements (see `perldoc perlnumber` and `perldoc perldata`)
such as ignoring embedded underscores (_).
.PP
.Vb 6
\&        Input     Number
\&        ------    ------
\&        100         100
\&        0x100       256
\&        0100         64
\&        0b100         4
.Ve
.PP
.Vb 4
\&        1_000      1000
\&        10.01     10.01
\&        1e3        1000
\&        1e+3      ERROR
.Ve
.PP
\&\fBNote:\fR Scientific notation for numbers only works (at this time) for
numbers with positive exponents, and the sign of the exponent must be
omitted (because the \fB+\fR or \fB\-\fR ends the number before it).
.PP
To enter 6.67x10^(\-11) you will have to compute it:
.PP
.Vb 3
\&           Input         Result
\&        ------------    --------
\&        6.67 1e11 /     6.67e-11
.Ve
.PP
\&\fBNote:\fR Negative numbers \fIcannot\fR be entered with a minus in front
of them (e.g. \-3) because the minus is parsed as the 'subtraction'
operation.  Instead, either compute the negative or use the \fBn\fR
operator to negate the last number
.PP
.Vb 5
\&        Input   Result
\&        ------  ------
\&        -3      ERROR
\&        0 3 -     -3
\&        3n        -3
.Ve
.PP
\fIParsing Operators\fR
.IX Subsection "Parsing Operators"
.PP
All operators are single characters.  They can be packed up against each other
or broken apart by white space or numbers.  They work in the stand \s-1RPN\s0 or Forth
fashion of 'popping' off as many arguments as they need and then pushing a result back onto the stack.
.PP
Noncommutative operators (i.e., \fB\-\fR, \fB/\fR, \fB%\fR, \fB:\fR) accept their arguments
in the order you would expect:
.PP
.Vb 3
\&        Input    Result
\&        ------   ------
\&        3 2 /     1.5
.Ve
.Sh "Operators"
.IX Subsection "Operators"
.IP "\fB+ \- * /\fR" 8
.IX Item "+ - * /"
Standard Arithmetic
.IP "\fB%\fR" 8
.IX Item "%"
Modulo; e.g. \f(CW\*(C`5 2 %\*(C'\fR gives \f(CW1\fR
.IP "\fB^\fR" 8
.IX Item "^"
Power; e.g. \f(CW\*(C`2 3 ^\*(C'\fR gives \f(CW8\fR
.IP "\fB& | ~\fR" 8
.IX Item "& | ~"
Standard C bitwise boolean operations
.IP "\fB`\fR" 8
.IX Item "`"
The C bitwise \s-1XOR\s0 operation (since ^ is the power function)
.IP "\fB:\fR" 8
.IX Item ":"
Combines hours and minutes into fractional hours; e.g. \f(CW\*(C`1 15\*(C'\fR : gives \f(CW1.25\fR
.IP "\fBf\fR" 8
.IX Item "f"
Floor: C floor function
.IP "\fBn\fR" 8
.IX Item "n"
Negate, change sign.  Same as \f(CW\*(C`0 s \-\*(C'\fR
.IP "\fBd\fR" 8
.IX Item "d"
Drop: Remove top of stack.
.IP "\fBs\fR" 8
.IX Item "s"
Swap: Exchange top two items on stack.
.IP "\fBu\fR" 8
.IX Item "u"
Dup: Make a copy of top of stack; e.g. \f(CW\*(C`2 u +\*(C'\fR gives \f(CW4\fR
.IP "\fBo\fR" 8
.IX Item "o"
Over: Make a copy of second on stack and put on top; e.g. \f(CW\*(C`1 2 \- \-\*(C'\fR
gives \f(CW0\fR.
.IP "\fBP\fR" 8
.IX Item "P"
Pick: Make a copy of the nth item on the stack; e.g. \f(CW\*(C`10 20 30 40 3
p\*(C'\fR gives \f(CW\*(C`10 20 30 40 20\*(C'\fR.  \fBu\fR is the same as \f(CW\*(C`1 p\*(C'\fR.  \fBo\fR is the
same as \f(CW\*(C`2 p\*(C'\fR.
.IP "\fB0xnnn\fR" 8
.IX Item "0xnnn"
Enter a hex integer; e.g.  \f(CW0x100\fR gives \f(CW256\fR
.IP "\fBq\fR" 8
.IX Item "q"
.PD 0
.IP "\fBx\fR" 8
.IX Item "x"
.PD
Exit calc
.IP "\fB?\fR" 8
.IX Item "?"
Give a one-line summary of operations
.SH "SEE ALSO"
.IX Header "SEE ALSO"
\&\fIdc\fR\|(1), \fIforth\fR\|(1)
.SH "AUTHOR"
.IX Header "AUTHOR"
Robert Dowling <\fIrob at rtdti.com\fR>.
Download from <http://www.rtdti.com/sw>
